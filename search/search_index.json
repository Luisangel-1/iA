{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trabajos IA - Luis Angel Fuentes","text":""},{"location":"#trabajos-en-clase","title":"Trabajos en clase","text":"<p>Practica algoritmo A* </p>"},{"location":"#realizados","title":"Realizados","text":"<ul> <li>Evaluacion Landmarks</li> </ul>"},{"location":"Algoritmo%20Estrella/","title":"Algoritmo Estrella","text":"<p>import pygame import heapq</p>"},{"location":"Algoritmo%20Estrella/#definimos-el-tamano-de-la-cuadricula","title":"Definimos el tama\u00f1o de la cuadr\u00edcula","text":"<p>ROWS, COLS = 20, 20  # N\u00famero de filas y columnas TILE_SIZE = 30       # Tama\u00f1o de cada celda</p>"},{"location":"Algoritmo%20Estrella/#colores","title":"Colores","text":"<p>WHITE = (255, 255, 255) BLACK = (0, 0, 0) GREEN = (0, 255, 0) RED = (255, 0, 0) BLUE = (0, 0, 255) GRAY = (200, 200, 200)</p>"},{"location":"Algoritmo%20Estrella/#inicializa-pygame","title":"Inicializa Pygame","text":"<p>pygame.init() WIN = pygame.display.set_mode((COLS * TILE_SIZE, ROWS * TILE_SIZE)) pygame.display.set_caption(\"Algoritmo A*\")</p> <p>class Nodo:     def init(self, fila, col):         self.fila = fila         self.col = col         self.g = float('inf')  # Costo desde el inicio         self.h = 0  # Heur\u00edstica         self.f = float('inf')  # Costo total         self.padre = None         self.es_obstaculo = False</p> <pre><code>def __lt__(self, otro):\n    return self.f &lt; otro.f\n\ndef dibujar(self, color):\n    pygame.draw.rect(WIN, color, (self.col * TILE_SIZE, self.fila * TILE_SIZE, TILE_SIZE, TILE_SIZE))\n    pygame.draw.rect(WIN, BLACK, (self.col * TILE_SIZE, self.fila * TILE_SIZE, TILE_SIZE, TILE_SIZE), 1)\n</code></pre> <p>def heuristica(nodo, objetivo):     return 10 * (abs(nodo.fila - objetivo.fila) + abs(nodo.col - objetivo.col))</p> <p>def reconstruir_camino(nodo):     camino = []     while nodo:         camino.append(nodo)         nodo = nodo.padre     return camino[::-1]</p> <p>def a_estrella(grid, inicio, objetivo):     lista_abierta = []     lista_cerrada = set()</p> <pre><code>inicio.g = 0\ninicio.h = heuristica(inicio, objetivo)\ninicio.f = inicio.g + inicio.h\nheapq.heappush(lista_abierta, inicio)\n\nmovimientos = [\n    (-1, 0, 10), (1, 0, 10),  # Arriba, Abajo\n    (0, -1, 10), (0, 1, 10),  # Izquierda, Derecha\n    (-1, -1, 14), (-1, 1, 14),  # Diagonales\n    (1, -1, 14), (1, 1, 14)\n]\n\nwhile lista_abierta:\n    actual = heapq.heappop(lista_abierta)\n    lista_cerrada.add((actual.fila, actual.col))\n\n    if actual == objetivo:\n        return reconstruir_camino(actual), lista_cerrada\n\n    for dx, dy, costo_mov in movimientos:\n        fila_nueva, col_nueva = actual.fila + dx, actual.col + dy\n\n        if 0 &lt;= fila_nueva &lt; ROWS and 0 &lt;= col_nueva &lt; COLS:\n            vecino = grid[fila_nueva][col_nueva]\n\n            if vecino.es_obstaculo or (vecino.fila, vecino.col) in lista_cerrada:\n                continue\n\n            nuevo_g = actual.g + costo_mov\n\n            if nuevo_g &lt; vecino.g:\n                vecino.g = nuevo_g\n                vecino.h = heuristica(vecino, objetivo)\n                vecino.f = vecino.g + vecino.h\n                vecino.padre = actual\n                heapq.heappush(lista_abierta, vecino)\n\nreturn [], lista_cerrada  # No hay camino\n</code></pre>"},{"location":"Algoritmo%20Estrella/#generar-la-cuadricula","title":"Generar la cuadr\u00edcula","text":"<p>grid = [[Nodo(fila, col) for col in range(COLS)] for fila in range(ROWS)]</p>"},{"location":"Algoritmo%20Estrella/#variables-de-control","title":"Variables de control","text":"<p>inicio = None objetivo = None fase = 0  # 0: Seleccionar inicio, 1: Seleccionar fin, 2: Seleccionar obst\u00e1culos, 3: Ejecutar A* camino = [] lista_cerrada = set()</p>"},{"location":"Algoritmo%20Estrella/#bucle-principal","title":"Bucle principal","text":"<p>corriendo = True while corriendo:     WIN.fill(WHITE)</p> <pre><code>for fila in grid:\n    for nodo in fila:\n        if nodo.es_obstaculo:\n            nodo.dibujar(BLACK)\n        elif nodo in camino:\n            nodo.dibujar(GREEN)\n        elif (nodo.fila, nodo.col) in lista_cerrada:\n            nodo.dibujar(GRAY)\n\nif inicio:\n    inicio.dibujar(BLUE)\nif objetivo:\n    objetivo.dibujar(RED)\n\nfor evento in pygame.event.get():\n    if evento.type == pygame.QUIT:\n        corriendo = False\n\n    elif evento.type == pygame.MOUSEBUTTONDOWN:\n        x, y = pygame.mouse.get_pos()\n        fila, col = y // TILE_SIZE, x // TILE_SIZE\n\n        if fase == 0:  # Seleccionar inicio\n            inicio = grid[fila][col]\n            fase = 1\n        elif fase == 1:  # Seleccionar fin\n            if (fila, col) != (inicio.fila, inicio.col):\n                objetivo = grid[fila][col]\n                fase = 2\n        elif fase == 2:  # Colocar obst\u00e1culos\n            if (fila, col) != (inicio.fila, inicio.col) and (fila, col) != (objetivo.fila, objetivo.col):\n                grid[fila][col].es_obstaculo = not grid[fila][col].es_obstaculo\n\n    elif evento.type == pygame.KEYDOWN:\n        if evento.key == pygame.K_SPACE and fase == 2:  # Ejecutar A*\n            fase = 3\n            for fila in grid:\n                for nodo in fila:\n                    nodo.g = float('inf')\n                    nodo.f = float('inf')\n                    nodo.padre = None\n            camino, lista_cerrada = a_estrella(grid, inicio, objetivo)\n\npygame.display.update()\n</code></pre> <p>pygame.quit()</p>"},{"location":"Evualucacion%20LandMarks/","title":"Evaluacion landmarks","text":""},{"location":"Evualucacion%20LandMarks/#modelo-de-red-neuronal-para-identificacion-de-emociones","title":"Modelo de Red Neuronal para Identificaci\u00f3n de Emociones","text":""},{"location":"Evualucacion%20LandMarks/#tipo-de-red-neuronal","title":"Tipo de Red Neuronal","text":"<p>Red Neuronal Feedforward (MLP) Yo utilizaria un Multi-Layer Perceptron (MLP) ya que nos permitirua trabajar mejor con datos mas estructurados y num\u00e9ricos, como las coordenadas de los landmarks.</p>"},{"location":"Evualucacion%20LandMarks/#estructura-de-la-red","title":"Estructura de la Red","text":""},{"location":"Evualucacion%20LandMarks/#a-capa-de-entrada","title":"a) Capa de Entrada","text":"<ul> <li>Definici\u00f3n: Recibe como input los valores extra\u00eddos de los landmarks.</li> <li>N\u00famero m\u00e1ximo de entradas: </li> <li>Si se usan 468 landmarks con las tres coordenadas (x, y, z), se tienen 468 \u00d7 3 = 1404 entradas.</li> <li>Si se utilizan solo dos coordenadas (x, y), el m\u00e1ximo ser\u00eda 468 \u00d7 2 = 936 entradas.</li> </ul> <p>La elecci\u00f3n depende de la relevancia de cada dimensi\u00f3n para el reconocimiento de emociones.</p>"},{"location":"Evualucacion%20LandMarks/#b-capas-ocultas","title":"b) Capas Ocultas","text":"<ul> <li>Definici\u00f3n: Varias capas densas que aprenden representaciones de alto nivel a partir de los datos de entrada.</li> <li>Funci\u00f3n de activaci\u00f3n: </li> <li>Se recomienda ReLU (Rectified Linear Unit), que introduce no linealidad y ayuda a evitar problemas como el desvanecimiento del gradiente.</li> </ul>"},{"location":"Evualucacion%20LandMarks/#c-capa-de-salida","title":"c) Capa de Salida","text":"<ul> <li>Definici\u00f3n: Capa final encargada de generar la predicci\u00f3n de la emoci\u00f3n.</li> <li>Patr\u00f3n de salida: </li> <li>Se utiliza para clasificaci\u00f3n, donde cada componente del vector representa la probabilidad de una emoci\u00f3n espec\u00edfica (por ejemplo: felicidad, tristeza, sorpresa, enojo, miedo, asco).</li> <li>Funci\u00f3n de activaci\u00f3n: </li> <li>Se utiliza softmax para normalizar los valores de salida y obtener una distribuci\u00f3n de probabilidad (valores entre 0 y 1 que suman 1).</li> </ul>"},{"location":"Evualucacion%20LandMarks/#patrones-a-utilizar","title":"Patrones a Utilizar","text":"<ul> <li>Patrones de Entrada: </li> <li>Cada patr\u00f3n es un conjunto de coordenadas de landmarks normalizadas para hacer la red insensible a la escala y posici\u00f3n absoluta.</li> <li> <p>Es necesario contar con un conjunto de datos etiquetado, donde cada muestra (vector de landmarks) est\u00e9 asociado a una emoci\u00f3n determinada.</p> </li> <li> <p>Patrones de Salida: </p> </li> <li>Cada patr\u00f3n de salida es un vector one-hot que indica la emoci\u00f3n correspondiente.  </li> </ul>"},{"location":"Evualucacion%20LandMarks/#funcion-de-activacion-necesaria","title":"Funci\u00f3n de Activaci\u00f3n Necesaria","text":"<ul> <li>Capas Ocultas: </li> <li> <p>ReLU (Rectified Linear Unit): Favorece la convergencia r\u00e1pida y ayuda a mitigar el problema del gradiente desvanecido.</p> </li> <li> <p>Capa de Salida: </p> </li> <li>Softmax: Convierte los logits en probabilidades para cada clase, ideal para problemas de clasificaci\u00f3n m\u00faltiple.</li> </ul>"},{"location":"Evualucacion%20LandMarks/#numero-maximo-de-entradas","title":"N\u00famero M\u00e1ximo de Entradas","text":"<p>El n\u00famero m\u00e1ximo de entradas depende de la cantidad y dimensionalidad de los landmarks utilizados: - 468 landmarks \u00d7 3 coordenadas (x, y, z): 1404 entradas. - 468 landmarks \u00d7 2 coordenadas (x, y): 936 entradas.</p>"},{"location":"Evualucacion%20LandMarks/#valores-esperados-a-la-salida-de-la-red","title":"Valores Esperados a la Salida de la Red","text":"<ul> <li>Salida Final (Softmax): </li> <li> <p>Se espera obtener un vector de probabilidades, donde cada componente representa la probabilidad de que la entrada corresponda a una emoci\u00f3n espec\u00edfica.</p> </li> <li> <p>Interpretaci\u00f3n de Resultados: </p> </li> <li>El valor m\u00e1ximo en el vector de salida (idealmente cercano a 1) identifica la emoci\u00f3n predominante, mientras que los dem\u00e1s valores cercanos a 0 indican baja probabilidad para las otras clases.</li> </ul>"},{"location":"Evualucacion%20LandMarks/#valores-maximos-del-bias","title":"Valores M\u00e1ximos del Bias","text":"<ul> <li>Definici\u00f3n del Bias: </li> <li> <p>Los bias son par\u00e1metros ajustables que se suman a las entradas ponderadas, permitiendo desplazar la funci\u00f3n de activaci\u00f3n.</p> </li> <li> <p>Rango Inicial y L\u00edmites:</p> </li> <li>Inicializaci\u00f3n: <ul> <li>Se suelen inicializar en valores peque\u00f1os (por ejemplo, en un rango de <code>[-0.1, 0.1]</code>) para evitar la saturaci\u00f3n de las neuronas.</li> </ul> </li> <li>Durante el Entrenamiento: <ul> <li>No existe un l\u00edmite te\u00f3rico m\u00e1ximo para los bias, ya que se actualizan en funci\u00f3n del error del modelo. Su valor final depender\u00e1 del proceso de optimizaci\u00f3n y la magnitud de las activaciones.</li> </ul> </li> </ul>"}]}